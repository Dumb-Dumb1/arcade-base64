<xml xmlns="https://developers.google.com/blockly/xml"><variables></variables><block type="pxt-on-start" id="QD71[0_=2:xzrfA(H]mc" x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" id="GRY#}=8XThWY}?@yEupx"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace u8x3 {" line1="    // our &quot;alphabet&quot; stays the same" line2="    const _c = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;" line3="" line4="    /**" line5="     * Opaque &quot;encode&quot; function (Base64)" line6="     */" line7="    //% block=&quot;encrypt %txt&quot;" line8="    export function e1(txt: string): string {" line9="        let out = &quot;&quot;" line10="        let i = 0" line11="        while (i &lt; txt.length) {" line12="            const c1 = txt.charCodeAt(i++)" line13="            const c2 = i &lt; txt.length ? txt.charCodeAt(i++) : NaN" line14="            const c3 = i &lt; txt.length ? txt.charCodeAt(i++) : NaN" line15="            const x1 = c1 &gt;&gt; 2" line16="            const x2 = ((c1 &amp; 3) &lt;&lt; 4) | (c2 &gt;&gt; 4)" line17="            const x3 = ((c2 &amp; 15) &lt;&lt; 2) | (c3 &gt;&gt; 6)" line18="            const x4 = c3 &amp; 63" line19="            if (isNaN(c2)) {" line20="                out += _c.charAt(x1) + _c.charAt(x2) + &quot;==&quot;" line21="            } else if (isNaN(c3)) {" line22="                out += _c.charAt(x1) + _c.charAt(x2) + _c.charAt(x3) + &quot;=&quot;" line23="            } else {" line24="                out += _c.charAt(x1) + _c.charAt(x2) + _c.charAt(x3) + _c.charAt(x4)" line25="            }" line26="        }" line27="        return out" line28="    }" line29="" line30="    /**" line31="     * Opaque &quot;decode&quot; function (Base64)" line32="     */" line33="    //% block=&quot;decrypt %dat&quot;" line34="    export function d2(dat: string): string {" line35="        // strip any invalid" line36="        let clean = &quot;&quot;" line37="        for (let ch of dat) {" line38="            if (_c.indexOf(ch) &gt;= 0 || ch == &quot;=&quot;) clean += ch" line39="        }" line40="        dat = clean" line41="        let out2 = &quot;&quot;" line42="        let j = 0" line43="        while (j &lt; dat.length) {" line44="            const x12 = _c.indexOf(dat.charAt(j++))" line45="            const x22 = _c.indexOf(dat.charAt(j++))" line46="            const x32 = _c.indexOf(dat.charAt(j++))" line47="            const x42 = _c.indexOf(dat.charAt(j++))" line48="            const r1 = (x12 &lt;&lt; 2) | (x22 &gt;&gt; 4)" line49="            const r2 = ((x22 &amp; 15) &lt;&lt; 4) | (x32 &gt;&gt; 2)" line50="            const r3 = ((x32 &amp; 3) &lt;&lt; 6) | x42" line51="            out2 += String.fromCharCode(r1)" line52="            if (x32 != 64) out2 += String.fromCharCode(r2)" line53="            if (x42 != 64) out2 += String.fromCharCode(r3)" line54="        }" line55="        return out2" line56="    }" line57="" line58="    /**" line59="     * Caesar cipher encryption" line60="     */" line61="    //% block=&quot;encrypt %txt with Caesar cipher shift %shift&quot;" line62="    export function caesarEncrypt(txt: string, shift: number): string {" line63="        let out3 = &quot;&quot;" line64="        shift = shift % 26" line65="        if (shift &lt; 0) shift += 26  // ensure positive shift" line66="        for (let k = 0; k &lt; txt.length; k++) {" line67="            let c = txt.charCodeAt(k)" line68="            if (c &gt;= 65 &amp;&amp; c &lt;= 90) { // uppercase" line69="                out3 += String.fromCharCode((c - 65 + shift) % 26 + 65)" line70="            } else if (c &gt;= 97 &amp;&amp; c &lt;= 122) { // lowercase" line71="                out3 += String.fromCharCode((c - 97 + shift) % 26 + 97)" line72="            } else { // other characters" line73="                out3 += txt.charAt(k)" line74="            }" line75="        }" line76="        return out3" line77="    }" line78="" line79="    /**" line80="     * Caesar cipher decryption" line81="     */" line82="    //% block=&quot;decrypt %txt with Caesar cipher shift %shift&quot;" line83="    export function caesarDecrypt(txt: string, shift: number): string {" line84="        // decryption is just encryption with negative shift" line85="        return caesarEncrypt(txt, -shift)" line86="    }" line87="" line88="    /**" line89="     * XOR cipher encryption/decryption" line90="     */" line91="    //% block=&quot;apply XOR cipher to %txt with key %key&quot;" line92="    export function xorCipher(txt: string, key: string): string {" line93="        let out4 = &quot;&quot;" line94="        for (let l = 0; l &lt; txt.length; l++) {" line95="            const d = txt.charCodeAt(l)" line96="            const m = key.charCodeAt(l % key.length)" line97="            out4 += String.fromCharCode(d ^ m)" line98="        }" line99="        return out4" line100="    }" line101="" line102="    /**" line103="     * Validates substitution key requirements" line104="     */" line105="    function validateSubstitutionKey(key: string): void {" line106="        // Check length" line107="        if (key.length !== 26) {" line108="            control.fail(&quot;Key must be exactly 26 letters long&quot;);" line109="        }" line110="" line111="        // Check all characters are uppercase letters" line112="        for (let n = 0; n &lt; key.length; n++) {" line113="            const char = key.charAt(n);" line114="            if (char &lt; &quot;A&quot; || char &gt; &quot;Z&quot;) {" line115="                control.fail(&quot;Key must contain only uppercase letters (A-Z)&quot;);" line116="            }" line117="        }" line118="" line119="        // Check for duplicates" line120="        for (let o = 0; o &lt; key.length; o++) {" line121="            for (let p = o + 1; p &lt; key.length; p++) {" line122="                if (key.charAt(o) === key.charAt(p)) {" line123="                    control.fail(&quot;Key must not contain duplicate letters&quot;);" line124="                }" line125="            }" line126="        }" line127="    }" line128="" line129="    /**" line130="     * Generate a random substitution key" line131="     */" line132="    //% block=&quot;generate substitution key&quot;" line133="    export function generateSubstitutionKey(): string {" line134="        const letters = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;" line135="        let key = &quot;&quot;;" line136="        let available = letters.split(&quot;&quot;);" line137="" line138="        // Fisher-Yates shuffle algorithm" line139="        for (let q = available.length - 1; q &gt; 0; q--) {" line140="            const r = Math.floor(Math.random() * (q + 1));" line141="            // Swap elements" line142="            [available[q], available[r]] = [available[r], available[q]];" line143="        }" line144="" line145="        key = available.join(&quot;&quot;);" line146="        return key;" line147="    }" line148="" line149="    /**" line150="     * Simple substitution cipher encryption" line151="     */" line152="    //% block=&quot;encrypt %txt with substitution key %key&quot;" line153="    export function substitutionEncrypt(txt: string, key: string): string {" line154="        validateSubstitutionKey(key);" line155="" line156="        const alphabet = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot;;" line157="        const fullKey = key + key.toLowerCase(); // Create 52-char key" line158="        let out5 = &quot;&quot;;" line159="" line160="        for (let s = 0; s &lt; txt.length; s++) {" line161="            const e = txt.charAt(s);" line162="            const idx = alphabet.indexOf(e);" line163="" line164="            if (idx &gt;= 0) {" line165="                out5 += fullKey.charAt(idx);" line166="            } else {" line167="                out5 += e; // Non-alphabet characters unchanged" line168="            }" line169="        }" line170="        return out5;" line171="    }" line172="" line173="    /**" line174="     * Simple substitution cipher decryption" line175="     */" line176="    //% block=&quot;decrypt %txt with substitution key %key&quot;" line177="    export function substitutionDecrypt(txt: string, key: string): string {" line178="        validateSubstitutionKey(key);" line179="" line180="        const alphabet2 = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot;;" line181="        const fullKey2 = key + key.toLowerCase();" line182="        let out6 = &quot;&quot;;" line183="" line184="        for (let t = 0; t &lt; txt.length; t++) {" line185="            const f = txt.charAt(t);" line186="            const idx2 = fullKey2.indexOf(f);" line187="" line188="            if (idx2 &gt;= 0) {" line189="                out6 += alphabet2.charAt(idx2);" line190="            } else {" line191="                out6 += f; // Non-alphabet characters unchanged" line192="            }" line193="        }" line194="        return out6;" line195="    }" line196="" line197="    /**" line198="     * Reverse cipher encryption/decryption" line199="     */" line200="    //% block=&quot;reverse %txt&quot;" line201="    export function reverseCipher(txt: string): string {" line202="        let out7 = &quot;&quot;" line203="        for (let u = txt.length - 1; u &gt;= 0; u--) {" line204="            out7 += txt.charAt(u)" line205="        }" line206="        return out7" line207="    }" line208="" line209="    /**" line210="     * ROT13 encryption/decryption" line211="     */" line212="    //% block=&quot;apply ROT13 to %txt&quot;" line213="    export function rot13(txt: string): string {" line214="        // ROT13 is a special case of Caesar cipher with shift 13" line215="        return caesarEncrypt(txt, 13)" line216="    }" line217="" line218="    /**" line219="     * Atbash cipher encryption/decryption" line220="     */" line221="    //% block=&quot;apply Atbash cipher to %txt&quot;" line222="    export function atbash(txt: string): string {" line223="        const alphabet3 = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot;" line224="        const reverse = &quot;ZYXWVUTSRQPONMLKJIHGFEDCBAzyxwvutsrqponmlkjihgfedcba&quot;" line225="        let out8 = &quot;&quot;" line226="        for (let v = 0; v &lt; txt.length; v++) {" line227="            const g = txt.charAt(v)" line228="            const idx3 = alphabet3.indexOf(g)" line229="            if (idx3 &gt;= 0) {" line230="                out8 += reverse.charAt(idx3)" line231="            } else {" line232="                out8 += g" line233="            }" line234="        }" line235="        return out8" line236="    }" line237="}" numlines="238"></mutation></block></statement></block></xml>