<xml xmlns="https://developers.google.com/blockly/xml"><variables></variables><block type="pxt-on-start" id="KxL17uG(!(:xE@GW+G8S" x="20" y="20"><statement name="HANDLER"><block type="typescript_statement" id=",5t[af@R~6EM2hll$,`!"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace u8x3 {" line1="    // our &quot;alphabet&quot; stays the same" line2="    const _c = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;" line3="" line4="    /**" line5="     * Opaque &quot;encode&quot; function (Base64)" line6="     */" line7="    //% block=&quot;encrypt %txt&quot;" line8="    export function e1(txt: string): string {" line9="        let out = &quot;&quot;" line10="        let i = 0" line11="        while (i &lt; txt.length) {" line12="            const c1 = txt.charCodeAt(i++)" line13="            const c2 = i &lt; txt.length ? txt.charCodeAt(i++) : NaN" line14="            const c3 = i &lt; txt.length ? txt.charCodeAt(i++) : NaN" line15="" line16="            // Handle potential invalid characters" line17="            if (isNaN(c1)) continue" line18="" line19="            const x1 = c1 &gt;&gt; 2" line20="            const x2 = ((c1 &amp; 3) &lt;&lt; 4) | (isNaN(c2) ? 0 : (c2 &gt;&gt; 4))" line21="            const x3 = isNaN(c2) ? 0 : ((c2 &amp; 15) &lt;&lt; 2) | (isNaN(c3) ? 0 : (c3 &gt;&gt; 6))" line22="            const x4 = isNaN(c3) ? 0 : (c3 &amp; 63)" line23="" line24="            if (isNaN(c2)) {" line25="                out += _c.charAt(x1) + _c.charAt(x2) + &quot;==&quot;" line26="            } else if (isNaN(c3)) {" line27="                out += _c.charAt(x1) + _c.charAt(x2) + _c.charAt(x3) + &quot;=&quot;" line28="            } else {" line29="                out += _c.charAt(x1) + _c.charAt(x2) + _c.charAt(x3) + _c.charAt(x4)" line30="            }" line31="        }" line32="        return out" line33="    }" line34="" line35="    /**" line36="     * Opaque &quot;decode&quot; function (Base64) - FIXED VERSION" line37="     */" line38="    //% block=&quot;decrypt %dat&quot;" line39="    export function d2(dat: string): string {" line40="        // strip any invalid" line41="        let clean = &quot;&quot;" line42="        for (let ch of dat) {" line43="            if (_c.indexOf(ch) &gt;= 0 || ch == &quot;=&quot;) clean += ch" line44="        }" line45="        dat = clean" line46="        let out2 = &quot;&quot;" line47="        let j = 0" line48="        while (j &lt; dat.length) {" line49="            // Get the next 4 characters" line50="            const c12 = dat.charAt(j++)" line51="            const c22 = dat.charAt(j++)" line52="            const c32 = dat.charAt(j++)" line53="            const c4 = dat.charAt(j++)" line54="" line55="            // If we don't have 4 characters, break" line56="            if (c12 === undefined || c22 === undefined || c32 === undefined || c4 === undefined) {" line57="                break" line58="            }" line59="" line60="            // Get indices for the first two characters (must be valid)" line61="            const x12 = _c.indexOf(c12)" line62="            const x22 = _c.indexOf(c22)" line63="" line64="            // If the first two are invalid, skip this group" line65="            if (x12 &lt; 0 || x22 &lt; 0) {" line66="                continue" line67="            }" line68="" line69="            // Check for padding in the third character" line70="            if (c32 === '=') {" line71="                // Then the fourth must also be '=' (we have one byte)" line72="                const r1 = (x12 &lt;&lt; 2) | (x22 &gt;&gt; 4)" line73="                out2 += String.fromCharCode(r1)" line74="                continue" line75="            }" line76="" line77="            // Get the index for the third character" line78="            const x32 = _c.indexOf(c32)" line79="            if (x32 &lt; 0) {" line80="                continue" line81="            }" line82="" line83="            // Check for padding in the fourth character" line84="            if (c4 === '=') {" line85="                // We have two bytes" line86="                const r12 = (x12 &lt;&lt; 2) | (x22 &gt;&gt; 4)" line87="                const r2 = ((x22 &amp; 15) &lt;&lt; 4) | (x32 &gt;&gt; 2)" line88="                out2 += String.fromCharCode(r12)" line89="                out2 += String.fromCharCode(r2)" line90="                continue" line91="            }" line92="" line93="            // Get the index for the fourth character" line94="            const x42 = _c.indexOf(c4)" line95="            if (x42 &lt; 0) {" line96="                continue" line97="            }" line98="" line99="            // We have three bytes" line100="            const r13 = (x12 &lt;&lt; 2) | (x22 &gt;&gt; 4)" line101="            const r22 = ((x22 &amp; 15) &lt;&lt; 4) | (x32 &gt;&gt; 2)" line102="            const r3 = ((x32 &amp; 3) &lt;&lt; 6) | x42" line103="            out2 += String.fromCharCode(r13)" line104="            out2 += String.fromCharCode(r22)" line105="            out2 += String.fromCharCode(r3)" line106="        }" line107="        return out2" line108="    }" line109="" line110="    /**" line111="     * Caesar cipher encryption" line112="     */" line113="    //% block=&quot;encrypt %txt with Caesar cipher shift %shift&quot;" line114="    export function caesarEncrypt(txt: string, shift: number): string {" line115="        let out3 = &quot;&quot;" line116="        shift = shift % 26" line117="        if (shift &lt; 0) shift += 26  // ensure positive shift" line118="        for (let k = 0; k &lt; txt.length; k++) {" line119="            let c = txt.charCodeAt(k)" line120="            if (c &gt;= 65 &amp;&amp; c &lt;= 90) { // uppercase" line121="                out3 += String.fromCharCode((c - 65 + shift) % 26 + 65)" line122="            } else if (c &gt;= 97 &amp;&amp; c &lt;= 122) { // lowercase" line123="                out3 += String.fromCharCode((c - 97 + shift) % 26 + 97)" line124="            } else { // other characters" line125="                out3 += txt.charAt(k)" line126="            }" line127="        }" line128="        return out3" line129="    }" line130="" line131="    /**" line132="     * Caesar cipher decryption" line133="     */" line134="    //% block=&quot;decrypt %txt with Caesar cipher shift %shift&quot;" line135="    export function caesarDecrypt(txt: string, shift: number): string {" line136="        // decryption is just encryption with negative shift" line137="        return caesarEncrypt(txt, -shift)" line138="    }" line139="" line140="    /**" line141="     * XOR cipher encryption/decryption" line142="     */" line143="    //% block=&quot;apply XOR cipher to %txt with key %key&quot;" line144="    export function xorCipher(txt: string, key: string): string {" line145="        let out4 = &quot;&quot;" line146="        for (let l = 0; l &lt; txt.length; l++) {" line147="            const d = txt.charCodeAt(l)" line148="            const m = key.charCodeAt(l % key.length)" line149="            out4 += String.fromCharCode(d ^ m)" line150="        }" line151="        return out4" line152="    }" line153="" line154="    /**" line155="     * Validates substitution key requirements" line156="     */" line157="    function validateSubstitutionKey(key: string): void {" line158="        // Check length" line159="        if (key.length !== 26) {" line160="            control.fail(&quot;Key must be exactly 26 letters long&quot;);" line161="        }" line162="" line163="        // Check all characters are uppercase letters" line164="        for (let n = 0; n &lt; key.length; n++) {" line165="            const char = key.charAt(n);" line166="            if (char &lt; &quot;A&quot; || char &gt; &quot;Z&quot;) {" line167="                control.fail(&quot;Key must contain only uppercase letters (A-Z)&quot;);" line168="            }" line169="        }" line170="" line171="        // Check for duplicates" line172="        for (let o = 0; o &lt; key.length; o++) {" line173="            for (let p = o + 1; p &lt; key.length; p++) {" line174="                if (key.charAt(o) === key.charAt(p)) {" line175="                    control.fail(&quot;Key must not contain duplicate letters&quot;);" line176="                }" line177="            }" line178="        }" line179="    }" line180="" line181="    /**" line182="     * Generate a random substitution key" line183="     */" line184="    //% block=&quot;generate substitution key&quot;" line185="    export function generateSubstitutionKey(): string {" line186="        const letters = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;" line187="        let key = &quot;&quot;;" line188="        let available = letters.split(&quot;&quot;);" line189="" line190="        // Fisher-Yates shuffle algorithm" line191="        for (let q = available.length - 1; q &gt; 0; q--) {" line192="            const r = Math.floor(Math.random() * (q + 1));" line193="            // Swap elements" line194="            [available[q], available[r]] = [available[r], available[q]];" line195="        }" line196="" line197="        key = available.join(&quot;&quot;);" line198="        return key;" line199="    }" line200="" line201="    /**" line202="     * Simple substitution cipher encryption" line203="     */" line204="    //% block=&quot;encrypt %txt with substitution key %key&quot;" line205="    export function sE(txt: string, key: string): string {" line206="        validateSubstitutionKey(key);" line207="" line208="        const alphabet = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot;;" line209="        const fullKey = key + key.toLowerCase(); // Create 52-char key" line210="        let out5 = &quot;&quot;;" line211="" line212="        for (let s = 0; s &lt; txt.length; s++) {" line213="            const e = txt.charAt(s);" line214="            const idx = alphabet.indexOf(e);" line215="" line216="            if (idx &gt;= 0) {" line217="                out5 += fullKey.charAt(idx);" line218="            } else {" line219="                out5 += e; // Non-alphabet characters unchanged" line220="            }" line221="        }" line222="        return out5;" line223="    }" line224="" line225="    /**" line226="     * Simple substitution cipher decryption" line227="     */" line228="    //% block=&quot;decrypt %txt with substitution key %key&quot;" line229="    export function sD(txt: string, key: string): string {" line230="        validateSubstitutionKey(key);" line231="" line232="        const alphabet2 = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot;;" line233="        const fullKey2 = key + key.toLowerCase();" line234="        let out6 = &quot;&quot;;" line235="" line236="        for (let t = 0; t &lt; txt.length; t++) {" line237="            const f = txt.charAt(t);" line238="            const idx2 = fullKey2.indexOf(f);" line239="" line240="            if (idx2 &gt;= 0) {" line241="                out6 += alphabet2.charAt(idx2);" line242="            } else {" line243="                out6 += f; // Non-alphabet characters unchanged" line244="            }" line245="        }" line246="        return out6;" line247="    }" line248="" line249="    /**" line250="     * Reverse cipher encryption/decryption" line251="     */" line252="    //% block=&quot;reverse %txt&quot;" line253="    export function rC(txt: string): string {" line254="        let out7 = &quot;&quot;" line255="        for (let u = txt.length - 1; u &gt;= 0; u--) {" line256="            out7 += txt.charAt(u)" line257="        }" line258="        return out7" line259="    }" line260="" line261="    /**" line262="     * ROT13 encryption/decryption" line263="     */" line264="    //% block=&quot;apply ROT13 to %txt&quot;" line265="    export function rot13(txt: string): string {" line266="        // ROT13 is a special case of Caesar cipher with shift 13" line267="        return caesarEncrypt(txt, 13)" line268="    }" line269="" line270="    /**" line271="     * Atbash cipher encryption/decryption" line272="     */" line273="    //% block=&quot;apply Atbash cipher to %txt&quot;" line274="    export function atbash(txt: string): string {" line275="        const alphabet3 = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot;" line276="        const reverse = &quot;ZYXWVUTSRQPONMLKJIHGFEDCBAzyxwvutsrqponmlkjihgfedcba&quot;" line277="        let out8 = &quot;&quot;" line278="        for (let v = 0; v &lt; txt.length; v++) {" line279="            const g = txt.charAt(v)" line280="            const idx3 = alphabet3.indexOf(g)" line281="            if (idx3 &gt;= 0) {" line282="                out8 += reverse.charAt(idx3)" line283="            } else {" line284="                out8 += g" line285="            }" line286="        }" line287="        return out8" line288="    }" line289="}" numlines="290"></mutation></block></statement></block></xml>